#!/usr/bin/env bash
# pkgit - package it!
set -euo pipefail

VERSION="0.0.1"

ROOT="/var/lib/pkgit"
BIN_DIR="/usr/local/bin"
LIB_DIR="/usr/lib"
INCLUDE_DIR="/usr/include"

REPOS_DIR="$ROOT/repos"
PKGS_DIR="$ROOT/pkgs"
BUILD_DIR="$ROOT/build"

PKGIT_ESSENTIAL_DIRS=(
    "$ROOT"
    "$REPOS_DIR"
    "$PKGS_DIR"
    "$BUILD_DIR"
    "$BIN_DIR"
)

red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
magenta='\033[0;35m'
cyan='\033[0;36m'
gray='\033[0;37m'
bold_red='\033[1;31m'
bold_green='\033[1;32m'
bold_yellow='\033[1;33m'
bold_blue='\033[1;34m'
bold_magenta='\033[1;35m'
bold_cyan='\033[1;36m'
bold_gray='\033[1;37m'
reset='\033[0m'

color() {
    echo "${1}$2${reset}"
}

or() {
    color "$yellow" "|"
}

exmpl() {
    color "$blue" "$1"
}

shortopt() {
    if [ $# == 2 ]; then
        echo "$(color "$bold_green" "$1") $(exmpl "$2")"
    else
        color "$bold_green" "$1"
    fi
}

longopt() {
    if [ $# == 2 ]; then
        echo "$(color "$cyan" "$1") $(exmpl "$2")"
    else
        color "$cyan" "$1"
    fi
}

desc() {
    color "$gray" "$1"
}

mkdir_cmd() {
    local dirs=("$@")
    mkdir -p "${dirs[@]}"
}

for dir in "${PKGIT_ESSENTIAL_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        echo "[pkgit] your system is missing some essential pkgit directories."
        echo "[pkgit] auto-generating pkgit directories..."
        mkdir_cmd "$dir"
    fi
done

update_latest_symlink() {
    local pkg="$1" ver="$2"
    local pkgdir="$REPOS_DIR/$pkg"
    mkdir_cmd "$pkgdir" || return 1
    ln -sfn "$ver" "$pkgdir/LATEST.tmp" && mv -f "$pkgdir/LATEST.tmp" "$pkgdir/LATEST"
}

create_repo_from_git() {
    local url="$1"
    local pkg=$(basename "$url" .git | tr '[:upper:]' '[:lower:]')
    local pkgdir="$REPOS_DIR/$pkg"
    mkdir -p "$pkgdir"

    echo "[pkgit] Creating repo(s) for $pkg from $url"

    local tags
    tags=$(git ls-remote --tags --refs "$url" 2>/dev/null | awk -F/ '{print $3}' |
        grep -E '^[0-9]+(\.[0-9]+)*$|^v[0-9]+(\.[0-9]+)*$' | sort -Vr) || {
        echo "[pkgit] Warning: Could not fetch tags from $url" >&2
        tags="HEAD"
    }
    [[ -n "$tags" ]] || tags="HEAD"

    for tag in $tags; do
        local verdir="$pkgdir/$tag"

        if [ ! -d "$verdir" ]; then
            mkdir -p "$verdir"

            local tmpclone
            tmpclone="$(mktemp -d)"
            if [[ "$tag" == "HEAD" ]]; then
                git -c advice.detachedHead=false clone --depth 1 "$url" "$tmpclone" >/dev/null 2>&1
            else
                git -c advice.detachedHead=false clone --branch "$tag" --depth 1 "$url" "$tmpclone" >/dev/null 2>&1
            fi

            if [[ -f "$tmpclone/bldit" ]]; then
                cp "$tmpclone/bldit" "$verdir/bldit"
                echo "[pkgit] Using repo-provided bldit for $pkg:$tag"
            else
                cp "$ROOT/bldit/bldit-default" "$verdir/bldit"
                echo "[pkgit] No bldit in repo, using default from $ROOT for $pkg:$tag"
            fi

            echo "$url" >>"$verdir/url"
            echo "$tag" >>"$verdir/ver"
            chmod +x "$verdir/bldit"
            rm -rf "$tmpclone"

            echo "[pkgit] Repo ready for $pkg $tag at $verdir"
        fi
    done

    local latest_tag
    latest_tag=$(echo "$tags" | head -n1)
    update_latest_symlink "$pkg" "$latest_tag"
    echo "[pkgit] LATEST symlink updated to $latest_tag"
}

store_link() {
    local link="$1"

    touch $REPOS_DIR/repos
    if [[ ! $(cat "$REPOS_DIR/repos") =~ "$link" ]]; then
        echo "$link" >>$REPOS_DIR/repos
    fi
}

install_pkg() {
    local input="$1"
    local pkg ver

    if [[ "$input" == *:* ]]; then
        pkg="${input%%:*}"
        ver="${input##*:}"
    else
        pkg="$input"
        ver="LATEST"
    fi
    pkg=$(echo "$pkg" | tr '[:upper:]' '[:lower:]')

    local repodir="$REPOS_DIR/$pkg/$ver"
    if [[ "$ver" == "LATEST" ]]; then
        if [[ -L "$REPOS_DIR/$pkg/LATEST" ]]; then
            repodir=$(readlink -f "$REPOS_DIR/$pkg/LATEST")
        else
            echo "[pkgit] No LATEST version for $pkg"
            return 1
        fi
    fi

    if [[ ! -f "$repodir/bldit" ]]; then
        if [[ ! -f "$ROOT/bldit/$pkg" ]]; then
            if [[ ! -f "$ROOT/bldit/bldit-default" ]]; then
                echo "[pkgit] No bldit found for $pkg:$ver"
                return 1
            fi
        fi
    fi

    echo "[pkgit] Installing $pkg:$ver ..."

    local build_dir="$BUILD_DIR/${pkg}-${ver}-$(date +%s)"
    rm -rf "$build_dir"
    mkdir -p "$build_dir"
    export ROOT PKGS_DIR BIN_DIR BUILD_DIR="$build_dir"

    local url="$(cd $repodir && cat url)"
    local tag="$(cd $repodir && cat ver)"
    echo "url: $url | pkg: $pkg | ver: $tag | bin-dir: $BIN_DIR | pkg-dir: $PKGS_DIR | build-dir: $BUILD_DIR"
    bash "$ROOT/bldit/$pkg" "$url" "$pkg" "$tag" "$BUILD_DIR" "$BIN_DIR" "$PKGS_DIR" ||
        bash "$repodir/bldit" "$url" "$pkg" "$tag" "$BUILD_DIR" "$BIN_DIR" "$PKGS_DIR" ||
        bash "$ROOT/bldit/bldit-default" "$url" "$pkg" "$tag" "$BUILD_DIR" "$BIN_DIR" "$PKGS_DIR" || {
        echo "[pkgit] Build FAILED for $pkg:$ver"
        return 1
    }
    echo "[pkgit] Build executed for $pkg:$ver"

    local installed_dir="$PKGS_DIR/$pkg/$ver"
    [[ -d "$installed_dir" ]] || installed_dir=$(find "$PKGS_DIR/$pkg" -mindepth 1 -maxdepth 1 -type d | sort | tail -n1)
    if [[ -d "$installed_dir" ]]; then
        ln -sfn "$installed_dir" "$PKGS_DIR/$pkg/LATEST"
        echo "[pkgit] Installed LATEST for $pkg -> $(basename "$installed_dir")"

        if [[ -d "$installed_dir/bin" ]]; then
            mkdir -p "$BIN_DIR"
            for f in "$installed_dir/bin/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$BIN_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/lib/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$LIB_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/include/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$INCLUDE_DIR/$(basename "$f")"
            done
            echo "[pkgit] Symlinked binaries for $pkg -> $BIN_DIR"
        fi
    else
        echo "[pkgit] WARNING: no installed files found for $pkg:$ver"
    fi

    echo "[pkgit] Finished install of $pkg:$ver"
}

remove_pkg() {
    local pkg=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$pkg" ]] && {
        echo "[pkgit] No package specified"
        return 1
    }
    [[ -d "$PKGS_DIR/$pkg" ]] || {
        echo "[pkgit] Package $pkg not installed"
        return 1
    }

    if [[ -d "$PKGS_DIR/$pkg/LATEST/bin" ]]; then
        for f in "$PKGS_DIR/$pkg/LATEST/bin/"*; do
            [[ -f "$f" ]] && rm -f "$BIN_DIR/$(basename "$f")"
        done
    fi

    rm -rf "$BIN_DIR/$pkg" "$PKGS_DIR/$pkg" "$BUILD_DIR/$pkg-"*
    echo "[pkgit] Removed $pkg"
}

remove_repo() {
    local repo=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$repo" ]] && {
        echo "[pkgit] No repo specified"
        return 1
    }
    [[ -d "$REPOS_DIR/$repo" ]] || {
        echo "[pkgit] Repo $repo does not exist"
        return 1
    }

    rm -rf "$REPOS_DIR/$repo"
    echo "[pkgit] Removed $repo"
}

search_pkgs() {
    local search_terms="${@:2}"
    echo ""
    for term in $search_terms; do
        echo "results for: $term"
        ls -1 "$REPOS_DIR" | grep -F "$term"
        echo ""
    done
}

list_pkgs() {
    ls "$PKGS_DIR" 2>/dev/null || echo "No packages installed"
}

list_repos() {
    ls "$REPOS_DIR" 2>/dev/null || echo "No repos exist"
}

CMD="${1:-}"
case "$CMD" in
i | install)
    shift
    [[ $# -eq 0 ]] && {
        echo "Usage: pkgit i <pkg[:ver]> ..."
        exit 1
    }
    for p in "$@"; do install_pkg "$p"; done
    ;;
r | remove)
    shift
    remove_pkg "${1:-}"
    ;;
rr | remove-repo)
    shift
    remove_repo "${1:-}"
    ;;
s | search)
    search_pkgs "$@"
    ;;
lp | list-pkgs)
    list_pkgs
    ;;
lr | list-repos)
    list_repos
    ;;
ar | add-repo)
    shift
    [[ -z "${1:-}" ]] && {
        echo "Usage: pkgit ar <git-url>"
        exit 1
    }
    create_repo_from_git "$1"
    store_link "$1"

    ;;
sy | sync)
    echo -e "$(color "$magenta" "[pkgit] *") Syncing repositories..."
    rm -rf "$REPOS_DIR/*/"
    while IFS= read -r repo; do
        echo ""
        echo -e "$(color "$blue" "Syncing:") $(color "$green" "$repo")"
        create_repo_from_git "$repo"
        echo -e "$(color "$blue" "Sync completed for:") $(color "$green" "$repo")"
    done <"$REPOS_DIR/repos"
    echo ""
    echo -e "$(color "$green" "[pkgit] *") Sync completed."
    ;;
up | update)
    echo -e "$(color "$magenta" "[pkgit] *") Updating installed packages..."
    for pkg in "$PKGS_DIR"/*; do
        qpkg=$(basename "$pkg")
        echo -e "$(color "$blue" "[pkgit] *") Updating: $qpkg"
        install_pkg "$qpkg"
        echo -e "$(color "$blue" "[pkgit] *") Update completed for: $qpkg"
    done
    echo ""
    echo -e "$(color "$green" "[pkgit] *") All installed packages have been updated."
    ;;
ug | upgrade)
    curl https://raw.githubusercontent.com/dacctal/pkgit/refs/heads/main/bldit | bash
    ;;
*)

    echo -e """$(color "$bold_magenta" "pkgit") - package it!
$(color "$magenta" "v$VERSION")

$(color "$red" "options:")
$(shortopt "ar" "[url.git]")    $(or)   $(longopt "add-repo" "[url.git]")    $(desc "# add a package to the local repo")
$(shortopt "i" "[pkgs]")        $(or)   $(longopt "install" "[pkgs]")        $(desc "# install a package from the repo")
$(shortopt "r" "[pkgs]")        $(or)   $(longopt "remove" "[pkgs]")         $(desc "# remove an installed package")
$(shortopt "rr" "[repos]")        $(or)   $(longopt "remove-repo" "[repos]")         $(desc "# remove a package repo")
$(shortopt "lp")              $(or)   $(longopt "list-pkgs")                  $(desc "# list installed packages")
$(shortopt "lr")              $(or)   $(longopt "list-repos")                  $(desc "# list local repos")
$(shortopt "s" "[pkgs]")        $(or)   $(longopt "search" "[pkgs]")         $(desc "# search for packages")
$(shortopt "sy")              $(or)   $(longopt "sync")                  $(desc "# update the repos")
$(shortopt "up")              $(or)   $(longopt "update")                $(desc "# update all installed packages")
$(shortopt "ug")              $(or)   $(longopt "upgrade")               $(desc "# update pkgit")
"""
    ;;
esac
