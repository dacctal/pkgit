#!/usr/bin/env bash

if command -v doas >/dev/null; then
    su=doas
elif command -v sudo >/dev/null; then
    su=sudo
else
    echo "[ERROR] Cannot get root access"
    exit 1
fi

set -euo pipefail

VERSION="0.0.1"

PKGIT_LOC=$(dirname "$(readlink -f "${BASH_SOURCE}")")
PKGIT_SCRIPT="$PKGIT_LOC/$(basename "${BASH_SOURCE[0]}")"

ROOT="/var/lib/pkgit"
BIN_DIR="/usr/local/bin"
LIB_DIR="/usr/lib"
INCLUDE_DIR="/usr/include"
PKGS_DIR="$ROOT/pkgs"
BUILD_DIR="$ROOT/build"

BLDIT_DIR="/etc/pkgit/bldit"
USER_REPOS_DIR="/etc/pkgit/repos"

PKGIT_ESSENTIAL_DIRS=(
    "$ROOT"
    "$BIN_DIR"
    "$LIB_DIR"
    "$INCLUDE_DIR"
    "$PKGS_DIR"
    "$BUILD_DIR"
)

PKGIT_CONFIG_DIRS=(
    "$BLDIT_DIR"
    "$USER_REPOS_DIR"
)

red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
magenta='\033[0;35m'
cyan='\033[0;36m'
gray='\033[0;37m'
bold_red='\033[1;31m'
bold_green='\033[1;32m'
bold_yellow='\033[1;33m'
bold_blue='\033[1;34m'
bold_magenta='\033[1;35m'
bold_cyan='\033[1;36m'
bold_gray='\033[1;37m'
reset='\033[0m'

color() {
    echo "${1}$2${reset}"
}

echo_pkgit() {
    echo -e "$(color "$yellow" "[")$(color "$magenta" "pkgit")$(color "$yellow" "]")"
}

echo_success() {
    echo -e $(color "$green" "[SUCCESS]")
}

or() {
    color "$yellow" "|"
}

exmpl() {
    color "$blue" "$1"
}

shortopt() {
    if [ $# == 2 ]; then
        echo "$(color "$bold_green" "$1") $(exmpl "$2")"
    else
        color "$bold_green" "$1"
    fi
}

longopt() {
    if [ $# == 2 ]; then
        echo "$(color "$cyan" "$1") $(exmpl "$2")"
    else
        color "$cyan" "$1"
    fi
}

desc() {
    color "$gray" "$1"
}

autogen() {
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    for dir in "${PKGIT_ESSENTIAL_DIRS[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo -e "$(echo_pkgit) successfully generated $dir"
        fi
    done
    for dir in "${PKGIT_CONFIG_DIRS[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo -e "$(echo_pkgit) successfully generated $dir"
        fi
    done
}

repo_from_git() {
    local url="$1"
    local req_tag="${2:-}"
    local pkg=$(basename "$url" .git | tr '[:upper:]' '[:lower:]')

    local tags
    if [[ -n "$req_tag" ]]; then
        tags="$req_tag"
    else
        tags=$(git ls-remote --tags --refs "$url" 2>/dev/null |
            awk -F/ '{print $3}' |
            grep -E '^[0-9]+(\.[0-9]+)*$|^v[0-9]+(\.[0-9]+)*$' |
            sort -Vr |
            head -n 1) || {
            echo -e "$(echo_pkgit) Warning: Could not fetch tags from $url" >&2
            tags="HEAD"
        }
        [[ -n "$tags" ]] || tags="HEAD"
    fi

    local latest_tag
    latest_tag=$(echo "$tags" | head -n 1)

    touch "$USER_REPOS_DIR/repos"
    if [[ ! $(grep "$url" "$USER_REPOS_DIR/repos") ]] ||
        [[ ! $(grep "${url%.git}" "$USER_REPOS_DIR/repos") ]]; then
        echo "$pkg $url" | tee -a "$USER_REPOS_DIR/repos" >/dev/null
    fi

    echo "$latest_tag"
}

add_repo_pkg() {
    [[ -z "${1:-}" ]] && {
        echo "Usage: pkgit arp <raw-file-url>"
        exit 1
    }
    if [[ "$1" == http* ]]; then
        file=$(curl "$1")
    else
        file=$(cat "$1")
    fi
    for url in $file; do
        repo_from_git "$url"
    done
}

sync() {
    echo -e "$(color "$magenta" "[pkgit]") Syncing repositories..."
    if [ -z "${2:-}" ]; then
        files=("$USER_REPOS_DIR"/*)
        echo ${files[@]}
        for file in "${files[@]}"; do
            while IFS= read -r repo; do
                echo ""
                echo -e "$(echo_pkgit) $(color "$blue" "[REPO]") Syncing: $(color "$green" "$repo")"
                repo_from_git "$repo"
                echo -e "$(echo_pkgit) $(echo_success) Sync completed for: $(color "$green" "$repo")"
            done <"$file"
        done
    else
        while IFS= read -r repo; do
            echo ""
            echo -e "$(echo_pkgit) $(color "$blue" "Syncing:") $(color "$green" "$repo")"
            repo_from_git "$repo"
            echo -e "$(echo_pkgit) $(color "$blue" "Sync completed for:") $(color "$green" "$repo")"
        done <"$USER_REPOS_DIR/${2:-*}"
    fi
    echo ""
    echo -e "$(echo_pkgit) $(echo_success) Sync completed."
}

build_sh() {
    set -euo pipefail

    PKGIT_GIT_URL="$1"
    pkg="$2"
    tag="$3"
    BUILD_DIR="$4"
    BIN_DIR="$5"
    PKGS_DIR="$6"

    INSTALL_DIR="$PKGS_DIR/$pkg/$tag"

    SRC_DIR="$BUILD_DIR/$pkg-$tag"
    rm -rf "$SRC_DIR"

    if [[ "$tag" == "HEAD" ]]; then
        git -c advice.detachedHead=false clone --depth 1 "$PKGIT_GIT_URL" "$SRC_DIR"
    else
        git -c advice.detachedHead=false clone --branch "$tag" --depth 1 "$PKGIT_GIT_URL" "$SRC_DIR"
    fi

    cd "$SRC_DIR"
    echo "$SRC_DIR"

    prompt_source_script() {
        local script="$1"
        echo -e "$(echo_pkgit) $(color "$yellow" "[YIELD]") Dependency script content:"
        echo ""
        echo "# --- START --- #"
        echo ""
        cat "$script"
        echo ""
        echo "# --- END --- #"
        echo ""
        read -rp "$(echo_pkgit) Do you trust this dependency script? (y/N) " answer
        if [[ "$answer" == [Yy]* ]]; then
            source "$script"
        else
            echo -e "$(echo_pkgit) Skipping $script"
            DEPS=()
        fi
    }

    if [ -f "/etc/pkgit/deps/$pkg.sh" ]; then
        echo -e "$(echo_pkgit) grabbing user-defined dependencies..."
        prompt_source_script "/etc/pkgit/deps/$pkg.sh"
    elif [ -f "deps.sh" ]; then
        echo -e "$(echo_pkgit) grabbing repo-defined dependencies..."
        chmod +x deps.sh
        prompt_source_script "deps.sh"
    else
        DEPS=()
    fi

    install_dependencies() {
        echo -e "$(echo_pkgit) Dependencies: ${DEPS[@]}"
        for dep in "${DEPS[@]:-}"; do
            [[ -z "$dep" ]] && continue

            url=$(awk '{print $1}' <<<"$dep")
            ver=$(awk '{print $2}' <<<"$dep")

            depname=$(basename "$url" .git | tr '[:upper:]' '[:lower:]')
            echo "[pkgit] Installing dependency: $depname (url: $url version: ${ver:-none})"

            if [[ -n "$ver" ]]; then
                $PKGIT_SCRIPT ar "$url" "$ver"
                $PKGIT_SCRIPT i "$depname:$ver"
            else
                $PKGIT_SCRIPT ar "$url"
                $PKGIT_SCRIPT i "$depname"
            fi
        done
    }

    install_bins() {
        find "$PKGS_DIR/$pkg/$tag" -type f -executable -exec ln -sf {} "$BIN_DIR" \;
    }

    copy_executables() {
        echo "Copying executable files recursively to $INSTALL_DIR"
        mkdir -p "$INSTALL_DIR"
        find . -type f -executable -exec cp --parents {} "$INSTALL_DIR" \;
    }

    build() {
        if [ -f "bldit" ]; then
            source bldit
            bldit
            copy_executables

        elif [ -f "autogen.sh" ]; then
            echo "Detected autogen.sh build system"
            ./autogen.sh --prefix="$INSTALL_DIR"
            make -j$(($(nproc) / 2))
            make install

        elif [ -f "cabal.project" ] || [ -f *".cabal" ]; then
            echo "Detected Cabal build system"
            cabal update
            cabal install --only-dependencies
            cabal configure --prefix="$INSTALL_DIR" -fembed_data_files
            cabal build
            cabal haddock --html-location=URL --hyperlink-source

        elif [ -f "Makefile" ]; then
            echo "Detected Make build system"
            make -j$(($(nproc) / 2))
            make install PREFIX="$INSTALL_DIR"

        elif [ -f "CMakeLists.txt" ]; then
            echo "Detected CMake build system"
            mkdir -p build
            cd build
            cmake -DCMAKE_INSTALL_PREFIX="$INSTALL_DIR" ..
            make
            make install
            cd ..

        elif [ -f "Cargo.toml" ]; then
            echo "Detected Cargo (Rust) build system"
            cargo build --release
            mkdir -p "$INSTALL_DIR/bin"
            cp -r target/release/* "$INSTALL_DIR/bin/"

        elif [ -f "build.zig" ]; then
            echo "Detected Zig build system"
            zig build -Dprefix="$INSTALL_DIR"
            zig build install

        elif [ -f "meson.build" ]; then
            echo "Detected Meson build system"
            meson setup build --prefix="$INSTALL_DIR"
            meson compile -C build
            meson install -C build

        elif [ -f "build.ninja" ]; then
            echo "Detected Ninja build system"
            ninja
            ninja install

        elif [ -f "SConstruct" ]; then
            echo "Detected SCons build system"
            scons prefix="$INSTALL_DIR"
            scons install prefix="$INSTALL_DIR"

        elif [ -f "configure.ac" ] || [ -f "configure" ]; then
            echo "Detected Autotools build system"
            ./configure --prefix="$INSTALL_DIR"
            make
            make install

        elif [ -f "build.gradle" ]; then
            if grep -q "kotlin" build.gradle; then
                echo "Detected Gradle Kotlin DSL build system"
            else
                echo "Detected Gradle build system"
            fi
            gradle build
            mkdir -p "$INSTALL_DIR/libs"
            cp build/libs/* "$INSTALL_DIR/libs/"

        elif [ -f "BUILD" ] || [ -f "WORKSPACE" ]; then
            echo "Detected Bazel build system"
            bazel build //:all
            copy_executables

        elif [ -f "BUCK" ]; then
            echo "Detected Buck build system"
            buck build //...
            copy_executables

        elif [ -f "pants.toml" ] || [ -f "pants.ini" ] || [ -f "pants.yaml" ]; then
            echo "Detected Pants build system"
            pants build ::
            copy_executables

        elif [ -f "flake.nix" ]; then
            echo "Detected Nix flake build system"
            nix build
            mkdir -p "$INSTALL_DIR"
            cp -r ./result/* "$INSTALL_DIR/"

        elif [ -f "default.nix" ]; then
            echo "Detected Nix build system"
            nix-build
            mkdir -p "$INSTALL_DIR"
            cp -r ./result/* "$INSTALL_DIR/"

        elif [ -f "build.sbt" ]; then
            echo "Detected SBT (Scala) build system"
            sbt compile
            sbt publishLocal
            copy_executables

        elif [ -f "esbuild.config.js" ] || [ -f "esbuild.config.ts" ]; then
            echo "Detected ESbuild build system"
            esbuild --outdir="$INSTALL_DIR"

        elif [ -f "webpack.config.js" ]; then
            echo "Detected Webpack build system"
            webpack --output-path "$INSTALL_DIR"

        elif [ -f "conanfile.txt" ] || [ -f "conanfile.py" ]; then
            echo "Detected Conan build system"
            conan install . --install-folder build --build=missing
            conan build . --build-folder build
            copy_executables

        elif [ -f "Earthfile" ]; then
            echo "Detected Earthly build system"
            earthly --build-arg INSTALL_DIR="$INSTALL_DIR" +default

        elif [ -f "dagger.hcl" ] || [ -f "dagger.yaml" ]; then
            echo "Detected Dagger build system"
            dagger do build
            copy_executables

        else
            echo "[pkgit] No recognized build system in $SRC_DIR"
            exit 1
        fi
    }

    install_dependencies
    build
    install_bins
    echo "Build and install completed successfully."
}

install_pkg() {
    local input="$1"
    local pkg ver
    if [[ "$input" == *:* ]]; then
        pkg="${input%%:*}"
        url=$(grep "$pkg" "$USER_REPOS_DIR"/* | awk '{print $2}')
        ver="${input##*:}"
    else
        pkg="$input"
        url=$(grep "$pkg" "$USER_REPOS_DIR"/* | awk '{print $2}')
        ver=$(repo_from_git $(grep "$url" "$USER_REPOS_DIR"/* | awk '{print $2}'))
    fi

    rm -rf "${BUILD_DIR}/${pkg}-"*

    if [ -d "$PKGS_DIR/$pkg/$ver" ]; then
        echo "$pkg:$ver already installed."
        exit 0
    fi

    if [[ ! -f "$BLDIT_DIR/$pkg" ]]; then
        echo -e "$(echo_pkgit) using default bldit for $pkg:$ver"
    fi

    echo -e "$(echo_pkgit) Installing $pkg:$ver ..."

    rm -rf "$BUILD_DIR/$pkg*"
    local build_dir="$BUILD_DIR/${pkg}-${ver}-$(date +%s)"
    rm -rf "$build_dir"
    mkdir -p "$build_dir"
    export ROOT PKGS_DIR BIN_DIR BUILD_DIR="$build_dir"

    local bldit_args=(
        "$url"
        "$pkg"
        "$ver"
        "$BUILD_DIR"
        "$BIN_DIR"
        "$PKGS_DIR"
    )

    echo """
    url: $url
    pkg: $pkg
    ver: $ver
    bin-dir: $BIN_DIR
    pkg-dir: $PKGS_DIR
    build-dir: $BUILD_DIR
    """

    default_bldit() {
        build_sh "${bldit_args[@]}"
    }

    default_bldit || {
        echo -e "$(echo_pkgit) Build FAILED for $pkg:$ver"
        return 1
    }
    echo -e "$(echo_pkgit) Build executed for $pkg:$ver"

    local installed_dir="$PKGS_DIR/$pkg/$ver"
    [[ -d "$installed_dir" ]] || installed_dir=$(find "$PKGS_DIR/$pkg" -mindepth 1 -maxdepth 1 -type d | sort | tail -n1)
    if [[ -d "$installed_dir" ]]; then
        ln -sfn "$installed_dir" "$PKGS_DIR/$pkg/HEAD"
        echo -e "$(echo_pkgit) Installed HEAD for $pkg -> $(basename "$installed_dir")"

        if [[ -d "$installed_dir/bin" ]]; then
            mkdir -p "$BIN_DIR"
            for f in "$installed_dir/bin/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$BIN_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/lib/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$LIB_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/include/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$INCLUDE_DIR/$(basename "$f")"
            done
            echo -e "$(echo_pkgit) Symlinked binaries for $pkg -> $BIN_DIR"
        fi
    else
        echo -e "$(echo_pkgit) WARNING: no installed files found for $pkg:$ver"
    fi

    echo -e "$(echo_pkgit) Finished install of $pkg:$ver"
}

update() {
    echo -e "$(echo_pkgit) $(color "$magenta" "[STATUS]") Updating installed packages..."
    for pkg in "$PKGS_DIR"/*; do
        qpkg=$(basename "$pkg")
        echo -e "$(echo_pkgit) $(color "$blue" "[PACKAGE]") Updating: $qpkg"
        install_pkg "$qpkg"
        echo -e "$(echo_pkgit) $(color "$blue" "[PACKAGE]") Update completed for: $qpkg"
    done
    echo ""
    echo -e "$(echo_pkgit) $(echo_success) All installed packages have been updated."
}

remove_pkg() {
    local pkg=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$pkg" ]] && {
        echo -e "$(echo_pkgit) No package specified"
        return 1
    }
    [[ -d "$PKGS_DIR/$pkg" ]] || {
        echo -e "$(echo_pkgit) Package $pkg not installed"
        return 1
    }

    if [[ -d "$PKGS_DIR/$pkg/LATEST/bin" ]]; then
        for f in "$PKGS_DIR/$pkg/LATEST/bin/"*; do
            [[ -f "$f" ]] && rm -f "$BIN_DIR/$(basename "$f")"
        done
    fi

    rm -rf "$BIN_DIR/$pkg" "$PKGS_DIR/$pkg" "$BUILD_DIR/$pkg-"*
    echo -e "$(echo_pkgit) Removed $pkg"
}

remove_repo() {
    local repo=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$repo" ]] && {
        echo -e "$(echo_pkgit) No repo specified"
        return 1
    }
    [[ $(grep "$repo" "$USER_REPOS_DIR"/*) ]] || {
        echo -e "$(echo_pkgit) Repo $repo does not exist"
        return 1
    }

    for file in "$USER_REPOS_DIR"/*; do
        sed -i "/$repo/d" $file
    done
    echo -e "$(echo_pkgit) Removed $repo"
}

list_pkgs() {
    ls "$PKGS_DIR" 2>/dev/null || echo "No packages installed"
}

list_repos() {
    cat "$USER_REPOS_DIR"/* || echo "No repos exist"
}

search_pkgs() {
    local search_terms="${@:2}"
    echo ""
    for term in $search_terms; do
        echo "results for: $term"
        grep -F "$term" "$USER_REPOS_DIR"/*
        echo ""
    done
}

pkgit_help() {
    echo -e """$(color "$bold_magenta" "pkgit") - package it!
$(color "$magenta" "v$VERSION")

$(color "$red" "options:")
$(shortopt "h")                   $(or)   $(longopt "help")                         $(desc "# display this help message")
$(shortopt "ar" "[url.git]")        $(or)   $(longopt "add-repo" "[url.git]")           $(desc "# add a package to your repo")
$(shortopt "ir" "[url.git]")        $(or)   $(longopt "install-repo " "[url.git]")      $(desc "# add and install a package")
$(shortopt "arp" "[url || file]")   $(or)   $(longopt "add-repo-pkg" "[url || file]")   $(desc "# add a list of repos")
$(shortopt "i" "[pkgs]")            $(or)   $(longopt "install" "[pkgs]")               $(desc "# install a package")
$(shortopt "r" "[pkgs]")            $(or)   $(longopt "remove" "[pkgs]")                $(desc "# remove an installed package")
$(shortopt "rr" "[repos]")          $(or)   $(longopt "remove-repo" "[repos]")          $(desc "# remove a package repo")
$(shortopt "lp")                  $(or)   $(longopt "list-pkgs")                    $(desc "# list installed packages")
$(shortopt "lr")                  $(or)   $(longopt "list-repos")                   $(desc "# list local repos")
$(shortopt "s" "[pkgs]")            $(or)   $(longopt "search" "[pkgs]")                $(desc "# search for packages")
$(shortopt "sy")                  $(or)   $(longopt "sync")                         $(desc "# update the repos")
$(shortopt "up")                  $(or)   $(longopt "update")                       $(desc "# update all installed packages")
$(shortopt "ug")                  $(or)   $(longopt "upgrade")                      $(desc "# update pkgit")
    """
}

# --- logic --- #

autogen $@

case ${1:-} in
ar | add-repo)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    repo_from_git $2
    ;;
arp | add-repo-pkg)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    add_repo_pkg $2
    ;;
ir | install-repo)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    repo_from_git ${@:2}
    install_pkg $(grep "$2" "$USER_REPOS_DIR"/* | awk '{print $1}')
    ;;
i | install)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    install_pkg $2
    ;;
r | remove)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    remove_pkg $2
    ;;
rr | remove-repo)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    remove_repo $2
    ;;
lp | list-pkgs)
    list_pkgs
    ;;
lr | list-repos)
    list_repos
    ;;
s | search)
    search_pkgs $@
    ;;
sy | sync)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    sync $@
    ;;
up | update)
    if ((EUID != 0)); then
        exec "$su" "$0" "$@"
    fi
    update
    ;;
ug | upgrade)
    curl https://raw.githubusercontent.com/dacctal/pkgit/refs/heads/main/bldit | bash
    ;;
h | help | *)
    pkgit_help
    ;;
esac
