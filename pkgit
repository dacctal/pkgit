#!/usr/bin/env bash
# pkgit - package it!
set -euo pipefail

VERSION="0.0.1"

ROOT="/var/lib/pkgit"
BIN_DIR="/usr/local/bin"
LIB_DIR="/usr/lib"
INCLUDE_DIR="/usr/include"

BLDIT_DIR="/etc/pkgit/bldit"
USER_REPOS_DIR="/etc/pkgit/repos"

REPOS_DIR="$ROOT/repos"
PKGS_DIR="$ROOT/pkgs"
BUILD_DIR="$ROOT/build"

PKGIT_ESSENTIAL_DIRS=(
    "$ROOT"
    "$REPOS_DIR"
    "$PKGS_DIR"
    "$BUILD_DIR"
    "$BIN_DIR"
)

red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
magenta='\033[0;35m'
cyan='\033[0;36m'
gray='\033[0;37m'
bold_red='\033[1;31m'
bold_green='\033[1;32m'
bold_yellow='\033[1;33m'
bold_blue='\033[1;34m'
bold_magenta='\033[1;35m'
bold_cyan='\033[1;36m'
bold_gray='\033[1;37m'
reset='\033[0m'

color() {
    echo "${1}$2${reset}"
}

echo_pkgit() {
    echo -e "$(color "$yellow" "[")$(color "$magenta" "pkgit")$(color "$yellow" "]")"
}

echo_success() {
    echo -e $(color "$green" "[SUCCESS]")
}

or() {
    color "$yellow" "|"
}

exmpl() {
    color "$blue" "$1"
}

shortopt() {
    if [ $# == 2 ]; then
        echo "$(color "$bold_green" "$1") $(exmpl "$2")" else
        color "$bold_green" "$1"
    fi
}

longopt() {
    if [ $# == 2 ]; then
        echo "$(color "$cyan" "$1") $(exmpl "$2")"
    else
        color "$cyan" "$1"
    fi
}

desc() {
    color "$gray" "$1"
}

mkdir_cmd() {
    local dirs=("$@")
    mkdir -p "${dirs[@]}"
}

for dir in "${PKGIT_ESSENTIAL_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        echo -e "$(echo_pkgit) your system is missing some essential pkgit directories."
        echo -e "$(echo_pkgit) auto-generating pkgit directories..."
        mkdir_cmd "$dir"
    fi
done

update_latest_symlink() {
    local pkg="$1" ver="$2"
    local pkgdir="$REPOS_DIR/$pkg"
    mkdir_cmd "$pkgdir" || return 1
    ln -sfn "$ver" "$pkgdir/LATEST.tmp" && mv -f "$pkgdir/LATEST.tmp" "$pkgdir/LATEST"
}

create_repo_from_git() {
    local url="$1"
    local requested_tag="${2:-}"
    local pkg=$(basename "$url" .git | tr '[:upper:]' '[:lower:]')
    local pkgdir="$REPOS_DIR/$pkg"
    mkdir -p "$pkgdir"

    echo -e "$(echo_pkgit) Creating repo(s) for $pkg from $url"

    local tags
    if [[ -n "$requested_tag" ]]; then
        tags="$requested_tag"
    else
        tags=$(git ls-remote --tags --refs "$url" 2>/dev/null | awk -F/ '{print $3}' |
            grep -E '^[0-9]+(\.[0-9]+)*$|^v[0-9]+(\.[0-9]+)*$' | sort -Vr | head -n 1) || {
            echo -e "$(echo_pkgit) Warning: Could not fetch tags from $url" >&2
            tags="HEAD"
        }
        [[ -n "$tags" ]] || tags="HEAD"
    fi

    for tag in $tags; do
        local verdir="$pkgdir/$tag"

        if [ ! -d "$verdir" ]; then
            mkdir -p "$verdir"

            local tmpclone
            tmpclone="$(mktemp -d)"
            if [[ "$tag" == "HEAD" ]]; then
                git -c advice.detachedHead=false clone --depth 1 "$url" "$tmpclone" >/dev/null 2>&1
            else
                git -c advice.detachedHead=false clone --branch "$tag" --depth 1 "$url" "$tmpclone" >/dev/null 2>&1
            fi

            if [[ -f "$tmpclone/bldit" ]]; then
                cp "$BLDIT_DIR/bldit-default" "$verdir/bldit"
                chmod +x "$verdir/bldit"
                echo -e "$(echo_pkgit) Using repo-provided bldit for $pkg:$tag"
            else
                echo -e "$(echo_pkgit) No bldit in repo, using default from $BLDIT_DIR for $pkg:$tag"
            fi

            if ! grep -qs "$url" "$verdir/url"; then
                echo "$url" >>"$verdir/url"
            fi
            if ! grep -qs "$tag" "$verdir/ver"; then
                echo "$tag" >>"$verdir/ver"
            fi
            rm -rf "$tmpclone"

            echo -e "$(echo_pkgit) $(echo_success) Repo ready for $(color "$green" "$pkg $tag") at $(color "$blue" "$verdir")"
        fi
    done

    local latest_tag
    latest_tag=$(echo "$tags" | head -n1)
    update_latest_symlink "$pkg" "$latest_tag"
    echo -e "$(echo_pkgit) LATEST symlink updated to $latest_tag"
}

store_link() {
    local link="$1"

    touch $USER_REPOS_DIR/repos
    #if [[ ! $(cat "$USER_REPOS_DIR/*") =~ "$link" ]]; then
    if [[ ! $(grep "$link" "$USER_REPOS_DIR"/*) ]]; then
        echo "$link" >>$USER_REPOS_DIR/repos
    fi
}

install_pkg() {
    local input="$1"
    local pkg ver

    if [[ "$input" == *:* ]]; then
        pkg="${input%%:*}"
        ver="${input##*:}"
    else
        pkg="$input"
        ver="LATEST"
    fi
    pkg=$(echo "$pkg" | tr '[:upper:]' '[:lower:]')

    if [ -d "$PKGS_DIR/$pkg/$ver" ]; then
        echo "$pkg:$ver already installed."
        exit 0
    fi

    local repodir="$REPOS_DIR/$pkg/$ver"
    if [[ "$ver" == "LATEST" ]]; then
        if [[ -L "$REPOS_DIR/$pkg/LATEST" ]]; then
            repodir=$(readlink -f "$REPOS_DIR/$pkg/LATEST")
        else
            echo -e "$(echo_pkgit) No LATEST version for $pkg"
            return 1
        fi
    fi

    if [[ ! -f "$BLDIT_DIR/$pkg" ]]; then
        if [[ ! -f "$BLDIT_DIR/bldit-default" ]]; then
            echo -e "$(echo_pkgit) No bldit found for $pkg:$ver"
            return 1
        fi
    fi

    if [ ! -d "$repodir" ]; then
        local url="$(cat $REPOS_DIR/$pkg/*/url | head -n 1)"
        if [[ "$ver" == "LATEST" ]]; then
            pkgit ar "$url"
        else
            pkgit ar "$url" "$ver"
        fi
    fi

    echo -e "$(echo_pkgit) Installing $pkg:$ver ..."

    rm -rf "$BUILD_DIR/$pkg*"
    local build_dir="$BUILD_DIR/${pkg}-${ver}-$(date +%s)"
    rm -rf "$build_dir"
    mkdir -p "$build_dir"
    export ROOT PKGS_DIR BIN_DIR BUILD_DIR="$build_dir"

    local url="$(cd $repodir && cat url)"
    local tag="$(cd $repodir && cat ver)"
    local bldit_args=(
        "$url"
        "$pkg"
        "$tag"
        "$BUILD_DIR"
        "$BIN_DIR"
        "$PKGS_DIR"
    )

    echo """
    url: $url
    pkg: $pkg
    ver: $tag
    bin-dir: $BIN_DIR
    pkg-dir: $PKGS_DIR
    build-dir: $BUILD_DIR
    """

    user_bldit() {
        echo -e "$(echo_pkgit) Trying user's bldit..."
        bash "$BLDIT_DIR/$pkg" "${bldit_args[@]}"
    }
    default_bldit() {
        echo -e "$(echo_pkgit) Trying default bldit..."
        bash "$BLDIT_DIR/bldit-default" "${bldit_args[@]}"
    }

    user_bldit || default_bldit || {
        echo -e "$(echo_pkgit) Build FAILED for $pkg:$ver"
        return 1
    }
    echo -e "$(echo_pkgit) Build executed for $pkg:$ver"

    local installed_dir="$PKGS_DIR/$pkg/$ver"
    [[ -d "$installed_dir" ]] || installed_dir=$(find "$PKGS_DIR/$pkg" -mindepth 1 -maxdepth 1 -type d | sort | tail -n1)
    if [[ -d "$installed_dir" ]]; then
        ln -sfn "$installed_dir" "$PKGS_DIR/$pkg/LATEST"
        echo -e "$(echo_pkgit) Installed LATEST for $pkg -> $(basename "$installed_dir")"

        if [[ -d "$installed_dir/bin" ]]; then
            mkdir -p "$BIN_DIR"
            for f in "$installed_dir/bin/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$BIN_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/lib/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$LIB_DIR/$(basename "$f")"
            done
            for f in "$installed_dir/include/"*; do
                [[ -f "$f" && -x "$f" ]] && ln -sf "$f" "$INCLUDE_DIR/$(basename "$f")"
            done
            echo -e "$(echo_pkgit) Symlinked binaries for $pkg -> $BIN_DIR"
        fi
    else
        echo -e "$(echo_pkgit) WARNING: no installed files found for $pkg:$ver"
    fi

    echo -e "$(echo_pkgit) Finished install of $pkg:$ver"
}

remove_pkg() {
    local pkg=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$pkg" ]] && {
        echo -e "$(echo_pkgit) No package specified"
        return 1
    }
    [[ -d "$PKGS_DIR/$pkg" ]] || {
        echo -e "$(echo_pkgit) Package $pkg not installed"
        return 1
    }

    if [[ -d "$PKGS_DIR/$pkg/LATEST/bin" ]]; then
        for f in "$PKGS_DIR/$pkg/LATEST/bin/"*; do
            [[ -f "$f" ]] && rm -f "$BIN_DIR/$(basename "$f")"
        done
    fi

    rm -rf "$BIN_DIR/$pkg" "$PKGS_DIR/$pkg" "$BUILD_DIR/$pkg-"*
    echo -e "$(echo_pkgit) Removed $pkg"
}

remove_repo() {
    local repo=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    [[ -z "$repo" ]] && {
        echo -e "$(echo_pkgit) No repo specified"
        return 1
    }
    [[ -d "$REPOS_DIR/$repo" ]] || {
        echo -e "$(echo_pkgit) Repo $repo does not exist"
        return 1
    }

    rm -rf "$REPOS_DIR/$repo"
    echo -e "$(echo_pkgit) Removed $repo"
}

search_pkgs() {
    local search_terms="${@:2}"
    echo ""
    for term in $search_terms; do
        echo "results for: $term"
        ls -1 "$REPOS_DIR" | grep -F "$term"
        echo ""
    done
}

list_pkgs() {
    ls "$PKGS_DIR" 2>/dev/null || echo "No packages installed"
}

list_repos() {
    ls "$REPOS_DIR" 2>/dev/null || echo "No repos exist"
}

CMD="${1:-}"
case "$CMD" in
i | install)
    shift
    [[ $# -eq 0 ]] && {
        echo "Usage: pkgit i <pkg[:ver]> ..."
        exit 1
    }
    for p in "$@"; do install_pkg "$p"; done
    ;;
r | remove)
    shift
    remove_pkg "${1:-}"
    ;;
rr | remove-repo)
    shift
    remove_repo "${1:-}"
    ;;
s | search)
    search_pkgs "$@"
    ;;
lp | list-pkgs)
    list_pkgs
    ;;
lr | list-repos)
    list_repos
    ;;
ar | add-repo)
    shift
    if [ "$1" == -i ]; then
        [[ -z "${2:-}" ]] && {
            echo "Usage: pkgit ar <git-url>"
            exit 1
        }
        create_repo_from_git "${2:-}" "${3:-}"
        store_link "${2:-}"

        pkg=$(basename "${2:-}" .git | tr '[:upper:]' '[:lower:]')
        install_pkg "$pkg"
    else
        [[ -z "${1:-}" ]] && {
            echo "Usage: pkgit ar <git-url>"
            exit 1
        }
        create_repo_from_git "$@"
        store_link "$1"
    fi
    ;;
apr | add-pkgit-repo)
    shift
    [[ -z "${1:-}" ]] && {
        echo "Usage: pkgit apr <raw-file-url>"
        exit 1
    }
    if "$1" == "http"*; then
        file=$(curl "$1")
    else
        file=$(cat "$1")
    fi
    for url in $file; do
        create_repo_from_git "$url"
        store_link "$url"
    done
    ;;
sy | sync)
    echo -e "$(color "$magenta" "[pkgit]") Syncing repositories..."
    rm -rf "$REPOS_DIR/*/"
    if [ -z "${2:-}" ]; then
        files=("$USER_REPOS_DIR"/*)
        echo ${files[@]}
        for file in ${files[@]}; do
            while IFS= read -r repo; do
                echo ""
                echo -e "$(echo_pkgit) $(color "$blue" "[REPO]") Syncing: $(color "$green" "$repo")"
                create_repo_from_git "$repo"
                echo -e "$(echo_pkgit) $(echo_success) Sync completed for: $(color "$green" "$repo")"
            done <"$file"
        done
    else
        while IFS= read -r repo; do
            echo ""
            echo -e "$(echo_pkgit) $(color "$blue" "Syncing:") $(color "$green" "$repo")"
            create_repo_from_git "$repo"
            echo -e "$(echo_pkgit) $(color "$blue" "Sync completed for:") $(color "$green" "$repo")"
        done <"$USER_REPOS_DIR/${2:-*}"
    fi
    echo ""
    echo -e "$(echo_pkgit) $(echo_success) Sync completed."
    ;;
up | update)
    echo -e "$(echo_pkgit) $(color "$magenta" "[STATUS]") Updating installed packages..."
    for pkg in "$PKGS_DIR"/*; do
        qpkg=$(basename "$pkg")
        echo -e "$(echo_pkgit) $(color "$blue" "[PACKAGE]") Updating: $qpkg"
        install_pkg "$qpkg"
        echo -e "$(echo_pkgit) $(color "$blue" "[PACKAGE]") Update completed for: $qpkg"
    done
    echo ""
    echo -e "$(echo_pkgit) $(echo_success) All installed packages have been updated."
    ;;
ug | upgrade)
    curl https://raw.githubusercontent.com/dacctal/pkgit/refs/heads/main/bldit | bash
    ;;
h | *)

    echo -e """$(color "$bold_magenta" "pkgit") - package it!
$(color "$magenta" "v$VERSION")

$(color "$red" "options:")
$(shortopt "h")                   $(or)   $(longopt "help")                         $(desc "# display this help message")
$(shortopt "ar" "[url.git]")        $(or)   $(longopt "add-repo" "[url.git]")           $(desc "# add a package to your repo")
$(shortopt "ar -i" "[url.git]")     $(or)   $(longopt "add-repo -i" "[url.git]")        $(desc "# add and install a package")
$(shortopt "apr" "[url || file]")   $(or)   $(longopt "add-pkgit-repo" "[url || file]") $(desc "# add a list of repos")
$(shortopt "i" "[pkgs]")            $(or)   $(longopt "install" "[pkgs]")               $(desc "# install a package")
$(shortopt "r" "[pkgs]")            $(or)   $(longopt "remove" "[pkgs]")                $(desc "# remove an installed package")
$(shortopt "rr" "[repos]")          $(or)   $(longopt "remove-repo" "[repos]")          $(desc "# remove a package repo")
$(shortopt "lp")                  $(or)   $(longopt "list-pkgs")                    $(desc "# list installed packages")
$(shortopt "lr")                  $(or)   $(longopt "list-repos")                   $(desc "# list local repos")
$(shortopt "s" "[pkgs]")            $(or)   $(longopt "search" "[pkgs]")                $(desc "# search for packages")
$(shortopt "sy")                  $(or)   $(longopt "sync")                         $(desc "# update the repos")
$(shortopt "up")                  $(or)   $(longopt "update")                       $(desc "# update all installed packages")
$(shortopt "ug")                  $(or)   $(longopt "upgrade")                      $(desc "# update pkgit")
"""
    ;;
esac
